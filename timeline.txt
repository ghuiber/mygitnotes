2012-02-06
Learning Git by doing: I will follow along with
http://www.sbf5.com/~cduan/technical/git/

I will document my progress from 1. Repositories to 5. Rebasing in this file.

1. Repositories

First, create a project directory:
In terminal, "cd ~/Documents/GitHub", then  "mkdir MyGitLessons". That's where this text file will be saved. Right now.
Next, "cd MyGitLessons", then "git init". This starts a repository.

Now, mark this file to be added the repository: "git add timeline.txt". Or, to add everything (which right now is just this file, but that might change), "git add .". What if I did both? It's all good.

Question: What if I "git add foo", where foo is a non-existent file? An error message will be thrown: "fatal: pathspec 'foo' did not match any files".

Now, add the file to the repository, really: "git commit". So, actual adding seems to happen in two steps: "git add" marks for addition, and "git commit" completes the addition. A commit message is required. You do "git commit -m "my first commit"" or you may do "git commit", but that will open vi and you will have to type in the commit message at the top, then exit with wq. So, it looks like you're typing in the actual file, but you're not. You can check that with "cat timeline.txt", which won't show the message, and with "git log" which will: so, you typed in the log, not in the file. All is well. Without a message, the commit is aborted. 

So, after the previous paragraph, I saved the file, and checked "git status" which showed a change between the version of timeline.txt that was committed and the version I just saved. The difference, of course, was the paragraph above. So, I did "git commit -a -m "I explained the commit"": -a means commit all that's changed, and -m means here comes the commit message. There. Now, I'll save and commit again, with the message "Commits are cheap."

Commits may be cheap, but you can't commit willy-nilly. If you try to do it twice in a row, ensuring that the second commit refers to a file that has suffered no modifications since the first commit, Git will respond tartly: "nothing to commit (working directory clean)".

Referring to a specific commit: each commit object has a SHA1 name. It's unique. Use it or its first few characters. For example, to check the difference between 2 objects, do "git diff object1 object2" where object1 and object2 are the first 7 characters of the two objects' SHA1 names. To check the difference between what is saved in your folder and the latest commit, type "git diff HEAD". In addition, each commit object has a head. That's just a reference to the object. The head of the current commit is HEAD, in all caps. In every repository, one head is always called master. Not sure yet why, or which head that is. It may have something to do with branching. 

Now, moving on to lesson 2: 

2. Branching

Say you're working on a paper, like this one, and commit after every paragraph. Your writing progresses one section at a time, and each section can consist of many paragraphs. Suppose that you are on section 2, and a draft you circulated came back with notes that require that you change a few things in section 1. Git lets you make those changes in a branch off the last commit of section 1. This leaves undisturbed whatever it is you're doing in section 2.

Example: as I'm going through this tutorial, I can't help having questions and wandering wherever Google or Stack Overflow sends me for answers. Just now, I learned that when you commit something you didn't mean to, and that's the current HEAD, you can fix it by committing the piece you want with "git commit --amend". This then makes the new commit the HEAD, and the previous will be discarded. That's a way to keep the chain of commit objects clean, I guess. Now I wonder if maybe I could cut out some intermediate commits. Surely, one after every paragraph is overkill. I know they're cheap, but I don't want to wade through a lot of them. In any case, nothing I'm writing about in this paragraph belongs under Branching. It should be added to the previous section, Repositories.
