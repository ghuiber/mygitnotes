2012-02-06
Learning Git by doing: I will follow along with
http://www.sbf5.com/~cduan/technical/git/

I will document my progress from 1. Repositories to 5. Rebasing in this file.

1. Repositories

First, create a project directory:
In terminal, "cd ~/Documents/GitHub", then  "mkdir MyGitLessons". That's where this text file will be saved. Right now.
Next, "cd MyGitLessons", then "git init". This starts a repository.

Now, mark this file to be added the repository: "git add timeline.txt". Or, to add everything (which right now is just this file, but that might change), "git add .". What if I did both? It's all good.

Question: What if I "git add foo", where foo is a non-existent file? An error message will be thrown: "fatal: pathspec 'foo' did not match any files".

Now, add the file to the repository, really: "git commit". So, actual adding seems to happen in two steps: "git add" marks for addition, and "git commit" completes the addition. A commit message is required. You do "git commit -m "my first commit"" or you may do "git commit", but that will open vi and you will have to type in the commit message at the top, then exit with wq. So, it looks like you're typing in the actual file, but you're not. You can check that with "cat timeline.txt", which won't show the message, and with "git log" which will: so, you typed in the log, not in the file. All is well. Without a message, the commit is aborted. 

So, after the previous paragraph, I saved the file, and checked "git status" which showed a change between the version of timeline.txt that was committed and the version I just saved. The difference, of course, was the paragraph above. So, I did "git commit -a -m "I explained the commit"": -a means commit all that's changed, and -m means here comes the commit message. There. Now, I'll save and commit again, with the message "Commits are cheap."

Commits may be cheap, but you can't commit willy-nilly. If you try to do it twice in a row, ensuring that the second commit refers to a file that has suffered no modifications since the first commit, Git will respond tartly: "nothing to commit (working directory clean)".

Referring to a specific commit: each commit object has a SHA1 name. It's unique. Use it or its first few characters. For example, to check the difference between 2 objects, do "git diff object1 object2" where object1 and object2 are the first 7 characters of the two objects' SHA1 names. To check the difference between what is saved in your folder and the latest commit, type "git diff HEAD". In addition, each commit object has a head. That's just a reference to the object. The head of the current commit is HEAD, in all caps. In every repository, one head is always called master. Not sure yet why, or which head that is. It may have something to do with branching. 

Bonus: when you commit something you didn't mean to, and that's the current HEAD, you can fix it by committing the piece you want with "git commit --amend". This then makes the new commit the HEAD, and the previous will be discarded. That's a way to keep the chain of commit objects clean, I guess. Now I wonder if maybe I could cut out some intermediate commits. Surely, one after every paragraph is overkill. I know they're cheap, but I don't want to wade through a lot of them. 

Now, moving on to lesson 2: 

2. Branching

Say you're working on a paper, like this one, and commit after every paragraph. Your writing progresses one section at a time, and each section can consist of many paragraphs. Suppose that you are on section 2, and a draft you circulated came back with notes that require that you change a few things in section 1. Git lets you make those changes in a branch off the last commit of section 1. This leaves undisturbed whatever it is you're doing in section 2.

Example: as I'm going through this tutorial, I can't help having questions and wandering wherever Google or Stack Overflow sends me for answers. Just now, I learned that when you commit something you didn't mean to, and that's the current HEAD, you can fix it by committing the piece you want with "git commit --amend". This then makes the new commit the HEAD, and the previous will be discarded. That's a way to keep the chain of commit objects clean, I guess. Now I wonder if maybe I could cut out some intermediate commits. Surely, one after every paragraph is overkill. I know they're cheap, but I don't want to wade through a lot of them. In any case, nothing I'm writing about in this paragraph belongs under Branching. It should be added to the previous section, Repositories.

So, I should start by "git branch gh_mention_amend 9c68ccc", which says that I'm going to create a branch called "gh_mention_amend" -- my initials, plus what I want to do" at the object with the name starting with 9c68ccc. That is the last commit of the Repositories section, according to "git log" (so, it's a good idea to have descriptive commit messages). If I save this file right now, and then try "git checkout gh_mention_amend" Git will admonish me that I have un-committed changes. Right. So, I commit first, then I "git checkout gh_mention_amend". A cool thing happens next: "vim timeline.txt" will put me in the version of this file saved before I started writing this Branching section. It's almost like I could freak out now: I can't see any of the work I did in this section! Did I lose it? Holy shit, did I?

No, I did not. It's in a different object: called master, it has the complete chain of commits. At this point I am free to make any changes I want to the Repositories section. When I save it, I will commit it to the gh_mention_amend branch. I'll go ahead and stop here for now, commit this piece, go back to "git_mention_amend", and add the bit about "git commit --ammend" to the Repositories section. Here's hoping I really didn't fuck anything up.

So far so good. I started a new branch, moved the bit about "git commit --ammend" to the end of the Repositories section in that new branch. Can't see it here though. Time to learn about branch merges?

Not yet. Before merging branches, here's how to look at them: "git branch" will list them with a star next to the current head. "git diff [head1]..[head2]" as well as "git diff [head2]..[head1]" does what you might expect: diffs them. It's useful to run it both ways, with the two heads switched. Three dots in-between will diff the latter vs. the common ancestor of the two. "git log [head1]..[head2]" shows the change log btw head2 and the common ancestor of head1 and head2. Again switching the two around helps. Three dots, not so useful here. Now we're ready to move on to merging.

So, I added a note about "git commit --amend" to the first section of this document, but I can't see it here as I'm typing this. I made that change inside the "gh_mention_amend" branch, and I am now in the "master" branch. Since that change is permanent and the final version of this document should reflect it, it is now time to merge the "gh_mention_amend" branch into the "master". Merging the branch with head A *into* the branch with head B means that your current commit is B, and you'll be drawing changes as of head A into the tail of head B. Nothing happens to head A. You can still switch to it with the "git checkout A" command and you'll find it in the state last committed. But when you "git checkout B" next, you will see all the changes incorporated in it. This has a graphical representation in "git log", as you will see soon.
